#!/bin/bash
#
# A CLI for the Routing Challenge.

# Constants
readonly APPS_PATH="apps/"
readonly CHARS_LINE="============================"
readonly CLI_SRC_PATH=".cli_src/"
readonly DOCKER_BUILD_RC_TESTER="rc-tester"

#######################################
# Display an error message when the user input is invalid.
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
#######################################
err() {
  echo "$0: $1" >&2
}

get_app_name() { # Strips off any leading directory components
  # Allows easy autocompletion in bash using created folder names
  # EG: my-image/ -> my-image, path/to/my/app/ -> app
  app_name="$(basename ${2:-''})"
}

get_solution_name() {
  input=$1
  image_name=$1
  while [[ -f "solutions/${input}.tar.gz" && -n ${input} ]]; do
    # Prompt confirmation to overwrite or rename image
    echo "Save Warning: Solution with name '${image_name}' exists"
    read -r -p "Enter a new name or overwrite [${image_name}]: " input
    [[ -n ${input} ]] && image_name=${input}
  done
}

check_app() {
  get_app_name "$@" # runs get_app_name to convert $2 to app_name
  if [[ $# -lt 2 ]]; then
    err "missing app operand"
    exit 1
  elif [[ ! -d "$APPS_PATH/${app_name}" ]]; then
    err "${app_name}: app not found"
    exit 1
  fi
}

check_solution() {
  get_app_name "$@"
  if [[ $# -lt 2 ]]; then
    err "missing solution operand"
    exit 1
  elif [[ ! -f "solutions/${app_name}.tar.gz" ]]; then
    err "${app_name}: solution not found"
    exit 1
  fi
}

build_image() {
  # $1
  # $2
  context="${3:-.}" # the third argument is the Docker context
  printf "\n${CHARS_LINE}\n"
  printf "Build Image [$2]:\n\n"
  printf "Building the '$2' image... "
  docker rmi "$2:rc-cli" >& /dev/null
  docker build --file ${context}/Dockerfile --tag $2:rc-cli ${context} >& \
    "logs/$1/$2-build-$(date --iso-8601=seconds).log"
  printf "done\n"
}

# Args
# $1: [setup,evaluate]
# $2: app_name
run_app_image() {
  docker_run_opts=${@:3}
  printf "\n${CHARS_LINE}\n"
  printf "Running App [$2] (${1^}):\n\n"
  docker run --rm --entrypoint "$1.sh" ${docker_run_opts} \
    --volume "$(pwd)/$2/data/$1_inputs:/home/app/data/$1_inputs:ro" \
    --volume "$(pwd)/$2/data/$1_outputs:/home/app/data/$1_outputs" \
    "$2:rc-cli" 2>&1 | tee "logs/$1/$2-$(date --iso-8601=seconds).log"
  printf "${CHARS_LINE}\n"
}

save_image() {
  printf "\n${CHARS_LINE}\n"
  printf "Save Image [$1]:\n\n"
  printf "Saving the '$1' image to 'solutions'... "
  docker save "$1:rc-cli" | gzip > "solutions/$1.tar.gz"
  printf "done\n"
}

run_test_image() {
  image_file="$2.tar.gz"
  data_path="$(pwd)/${CLI_SRC_PATH}/data"
  printf "${CHARS_LINE}\n"
  printf "Preparing Test Image [$2] to Run With [${DOCKER_BUILD_RC_TESTER}]:\n\n"
  docker run --privileged --rm --env IMAGE_FILE=${image_file} \
    --volume "$(pwd)/solutions/${image_file}:/mnt/${image_file}:ro" \
    --volume "${data_path}/setup_inputs:/data/setup_inputs:ro" \
    --volume "${data_path}/setup_outputs:/data/setup_outputs" \
    --volume "${data_path}/evaluate_inputs:/data/evaluate_inputs:ro" \
    --volume "${data_path}/evaluate_outputs:/data/evaluate_outputs" \
    "${DOCKER_BUILD_RC_TESTER}:rc-cli" 2>&1 | tee "./logs/$1/$2-run-$(date --iso-8601=seconds).log"
}

make_logs() { # Ensure the necessary log file structure for the calling command
  mkdir -p logs/$1
}

# Single main function
main() {
  if [[ $# -lt 1 ]]; then
    err "missing command operand"
    exit 1
  elif [[ $# -gt 2 ]]; then
    err "too many arguments"
    exit 1
  fi

  # Select the command
  case $1 in
    new) # Create a new app based on a template
      template="rc-python" # TODO: Retrieve the template option (-t, --template)
      app_path="${APPS_PATH}/$2"
      template_path="${CLI_SRC_PATH}/templates/${template}"
      if [[ $# -lt 2 ]]; then
        err "missing app operand"
        exit 1
      elif [[ -d "${app_path}" ]]; then
        err "$2: cannot create app: Already exists"
        exit 1
      elif [[ ! -d "${template_path}" ]]; then
        err "${template}: template not found"
        exit 1
      fi
      err "the templates option is not available yet"
      echo "The 'rc-python' template is set by default"
      cp --recursive "${template_path}" "${app_path}"
      chmod +x $(echo "${app_path}/*.sh")
      echo "Done."
      ;;

    setup | evaluate) # Build and run the '[setup,evaluate].sh' script
      if [[ $# -lt 2 ]]; then
        err "missing app operand"
        exit 1
      fi
      make_logs "$@"
      check_app "$@"
      app_path="${APPS_PATH}/${app_name}"
      build_image $1 ${app_name} ${app_path}
      [[ $1 = "evaluate" ]] \
        && docker_run_opts="--volume $(pwd)/${app_path}/data/setup_outputs:/home/app/data/setup_outputs:ro"
      run_app_image $1 ${app_name} ${docker_run_opts}
      ;;

    save) # Build the app image and save it to the 'solutions' directory
      make_logs "$@"
      check_app "$@" # Note: check_app runs get_app_name to convert $2 to app_name
      app_path="${APPS_PATH}/${app_name}"
      printf "${CHARS_LINE}\n"
      printf "Build and Save Image for App [${app_name}]:\n\n"
      get_solution_name ${app_name} # prompts for an image_name if the solution exists
      build_image $1 ${image_name} ${app_path}
      save_image ${image_name}
      printf "${CHARS_LINE}\n"
      ;;

    test)
      make_logs "$@"
      check_solution "$@" # Note: check_solution runs get_app_name to convert $2 to app_name
      # Saving time if the '${DOCKER_BUILD_RC_TESTER}' image exists.
      if [[ ! $(docker images --quiet ${DOCKER_BUILD_RC_TESTER}) ]]; then
        build_image $1 ${DOCKER_BUILD_RC_TESTER} ${CLI_SRC_PATH}
      fi
      run_test_image $1 ${app_name}
      printf "\n${CHARS_LINE}\n"
      ;;

    all) # Build, run and save the app image & validate it with the '${DOCKER_BUILD_RC_TESTER}'
      make_logs "$@"
      check_app "$@"
      app_path="${APPS_PATH}/${app_name}"
      printf "${CHARS_LINE}\n"
      printf "Build and Save Image for [${app_name}]:\n\n"
      get_solution_name ${app_name} # prompts for an image_name if the solution exists
      build_image $1 ${image_name} ${app_path}
      save_image ${image_name}
      # Saving time if the '${DOCKER_BUILD_RC_TESTER}' image exists.
      if [[ ! $(docker images --quiet ${DOCKER_BUILD_RC_TESTER}) ]]; then
        build_image $1 ${DOCKER_BUILD_RC_TESTER} ${CLI_SRC_PATH}
      fi
      run_test_image $1 ${image_name}
      printf "${CHARS_LINE}\n"
      ;;

    purge) # Remove all the logs, images and solutions created by 'rc-cli'.
      # TODO: Do it by specifying app_name
      if [[ $# -gt 1 ]]; then
        err "too many arguments"
        exit 1
      fi
      # Prompt confirmation to delete user
      echo "WARNING! This will remove all logs, Docker images and solutions created by $0"
      read -r -p "Are you sure you want to continue? [y/N] " input
      case ${input} in
        [yY][eE][sS] | [yY])
          echo -n "Removing logs... "
          rm --recursive --force "logs/"
          echo "done"

          echo -n "Removing images... "
          rc_images=$(docker images --all --filter reference="*:rc-cli" --quiet)
          if [[ ${rc_images} ]]; then
            docker rmi --force ${rc_images} >& /dev/null >&2
          fi
          echo "done"

          echo -n "Removing solutions... "
          rm --force solutions/*.tar.gz
          echo "done"
          echo "Finished!"
          ;;
        [nN][oO] | [nN] | "")
          err "purge was canceled by the user"
          ;;
        *)
          err "invalid input: The purge was canceled"
          exit 1
          ;;
      esac
      ;;

    debug) # Enable an interactive shell at runtime to debug the app container.
      check_app "$@"
      # Find all available shells in container and choose bash if available
      valid_sh=$(docker run --rm --entrypoint="" "${app_name}:rc-cli" cat /etc/shells)
      [[ -n $(echo ${valid_sh} | grep "/bin/bash") ]] \
        && app_sh="/bin/bash" || app_sh="/bin/sh"
      echo "Debug mode:"
      echo "  - the default shell is ${app_sh}"
      echo "  - find all valid login shells: cat /etc/shells"
      echo "  - switch to a preferred shell if available, e.g. /bin/zsh"
      echo -e "  - \033[1mno '*.sh' script has been run yet\033[0m"
      echo "  - use the 'exit' command to exit the current shell"
      echo
      echo "Enabling an interactive shell with the app container..."
      src_path="$(pwd)/${app_name}/data"
      dest_path="/home/app/data/"
      docker run --rm --entrypoint="" \
        --volume "${src_path}/setup_inputs:${dest_path}/setup_inputs:ro" \
        --volume "${src_path}/setup_outputs:${dest_path}/setup_outputs" \
        --volume "${src_path}/evaluate_inputs:${dest_path}/evaluate_inputs:ro" \
        --volume "${src_path}/evaluate_outputs:${dest_path}/evaluate_outputs" \
        -it "${app_name}:rc-cli" ${app_sh}
      ;;

    update) # Run maintenance commands after breaking changes on the framework.
      make_logs "$@"
      echo "Maintenance tasks will run now"
      build_image $1 ${DOCKER_BUILD_RC_TESTER} ${CLI_SRC_PATH}
      echo "Finished!"
      ;;

    *)
      err "$1: command not found"
      exit 1
      ;;
  esac
}

main "$@"
