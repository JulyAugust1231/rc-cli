#!/bin/bash
#
# A CLI for the Routing Challenge.

# Constants
readonly DOCKER_BUILD_RC_TESTER="rc-tester"
readonly TEXT_BORDER="============================"

#######################################
# Display an error message when the user input is invalid.
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
#######################################
err() {
  echo "$0: $1" >&2
}

get_app_name() { # Strips off any leading directory components
  # Allows easy autocompletion in bash using created folder names
  # EG: my-image/ -> my-image, path/to/my/app/ -> app
  app_name="$(basename ${2:-''})"
}

get_solution_name() {
  input=$1
  image_name=$1
  while [[ -f "solutions/${input}.tar.gz" && -n ${input} ]]; do
    # Prompt confirmation to overwrite or rename image
    echo "Save Warning: Solution with name '${image_name}' exists"
    read -r -p "Enter a new name or overwrite [${image_name}]: " input
    [[ -n ${input} ]] && image_name=${input}
  done
}

check_app() {
  get_app_name "$@" # runs get_app_name to convert $2 to app_name
  if [[ $# -lt 2 ]]; then
    err "missing app operand"
    exit 1
  elif [[ ! -d ${app_name} ]]; then
    err "${app_name}: app not found"
    exit 1
  fi
}

check_solution() {
  get_app_name "$@"
  if [[ $# -lt 2 ]]; then
    err "missing solution operand"
    exit 1
  elif [[ ! -f "solutions/${app_name}.tar.gz" ]]; then
    err "${app_name}: solution not found"
    exit 1
  fi
}

build_image() {
  context="${3:-.}"
  printf "\n${TEXT_BORDER}\n"
  printf "Build Image [$2]:\n\n"
  printf "Building the '$2' image... "
  docker rmi "$2:rc-cli" >& /dev/null
  docker build --file ${context}/Dockerfile --tag "$2:rc-cli" ${context} >& \
    "logs/$1/$2-build-$(date --iso-8601=seconds).log"
  printf "done\n"
}

run_app_image() {
  run_mode="${3:-setup}"
  printf "\n${TEXT_BORDER}\n"
  printf "Running App [$2] (${run_mode^}):\n\n"
  docker run --rm --entrypoint "$1.sh" $4 \
    --volume "$(pwd)/data/${run_mode}_inputs:/home/app/data/${run_mode}_inputs:ro" \
    --volume "$(pwd)/data/${run_mode}_outputs:/home/app/data/${run_mode}_outputs" \
    "$2-${run_mode}:rc-cli" 2>&1 | tee "logs/$1/$2-${run_mode}-$(date --iso-8601=seconds).log"
  printf "${TEXT_BORDER}\n"
}

save_image() {
  printf "\n${TEXT_BORDER}\n"
  printf "Save Image [$1]:\n\n"
  printf "Saving the '$1' image to 'solutions'... "
  docker save "$1:rc-cli" | gzip > "solutions/$1.tar.gz"
  printf "done\n"
}

run_test_image() {
  printf "${TEXT_BORDER}\n"
  printf "Preparing Test Image [$2] to Run With [${DOCKER_BUILD_RC_TESTER}]:\n\n"
  docker run --privileged --rm --env IMAGE_FILE=$2 \
    --volume "$(pwd)/solutions/$2:/mnt/$2:ro" \
    --volume "$(pwd)/data/inputs:/data/inputs:ro" \
    --volume "$(pwd)/data/outputs:/data/outputs" \
    "${DOCKER_BUILD_RC_TESTER}:rc-cli" 2>&1 | tee "./logs/$1/${app_name}-run-$(date --iso-8601=seconds).log"
}

make_logs() { # Ensure the necessary log file structure for the calling command
  mkdir -p logs/$1
}

# Single main function
main() {
  if [[ $# -lt 1 ]]; then
    err "missing command operand"
    exit 1
  elif [[ $# -gt 2 ]]; then
    err "too many arguments"
    exit 1
  fi

  # Select the command
  case $1 in
    new) # Create a new app based on a template
      # TODO: Retrieve the template option (-t, --template)
      t="rc-python"
      if [[ $# -lt 2 ]]; then
        err "missing app operand"
        exit 1
      elif [[ -d $2 ]]; then
        err "$2: cannot create app: Already exists"
        exit 1
      elif [[ ! -d "templates/$t" ]]; then
        err "$t: template not found"
        exit 1
      fi
      err "the templates option is not available yet"
      echo "The 'rc-python' template is set by default"
      cp --recursive "templates/$t" $2
      chmod +x $(echo "$2/*.sh")
      echo "Done."
      ;;

    setup) # Build and run the 'setup.sh' script
      if [[ $# -lt 2 ]]; then
        err "missing app operand"
        exit 1
      fi
      make_logs "$@"
      check_app "$@"
      build_image $1 "${app_name}-$1" ${app_name} # the third argument is the Docker context
      run_app_image $1 ${app_name}
      ;;

    evaluate) # Build and run the 'evaluate.sh' script
      if [[ $# -lt 2 ]]; then
        err "missing app operand"
        exit 1
      fi
      make_logs "$@"
      check_app "$@"
      build_image $1 "${app_name}-$1" ${app_name} # the third argument is the Docker context
      extra_opts=\
        "--volume '$(pwd)/data/setup_outputs:/home/app/data/setup_outputs:ro' \
        "
      # TODO: Depending on how we handle the 'save' command,
      # we can drop the third argument (run_mode)
      run_app_image $1 ${app_name} $1 ${extra_opts}
      ;;

    save) # Build the app image and save it to the 'solutions' directory
      make_logs "$@"
      check_app "$@" # Note: check_app runs get_app_name to convert $2 to app_name
      printf "${TEXT_BORDER}\n"
      printf "Build and Save Image for App [${app_name}]:\n\n"
      get_solution_name ${app_name} # prompts for an image_name if the solution exists
      build_image $1 ${image_name} ${app_name} # the third argument is the Docker context
      save_image ${image_name}
      printf "${TEXT_BORDER}\n"
      ;;

    test)
      make_logs "$@"
      check_solution "$@" # Note: check_solution runs get_app_name to convert $2 to app_name
      # Saving time if the '${DOCKER_BUILD_RC_TESTER}' image exists.
      if [[ ! $(docker images --quiet ${DOCKER_BUILD_RC_TESTER}) ]]; then
        build_image $1 ${DOCKER_BUILD_RC_TESTER}
      fi
      run_test_image $1 "${app_name}.tar.gz"
      printf "\n${TEXT_BORDER}\n"
      ;;

    all) # Build, run and save the app image & validate it with the '${DOCKER_BUILD_RC_TESTER}'
      make_logs "$@"
      check_app "$@"
      printf "${TEXT_BORDER}\n"
      printf "Build and Save Image for [${app_name}]:\n\n"
      get_solution_name ${app_name} # prompts for an image_name if the solution exists
      build_image $1 ${image_name} ${app_name} # the third argument is the Docker context
      save_image ${image_name}

      # Saving time if the '${DOCKER_BUILD_RC_TESTER}' image exists.
      if [[ ! $(docker images --quiet ${DOCKER_BUILD_RC_TESTER}) ]]; then
        build_image $1 ${DOCKER_BUILD_RC_TESTER}
      fi
      run_test_image $1 "${image_name}.tar.gz"
      printf "${TEXT_BORDER}\n"
      ;;

    purge) # Remove all the logs, images and solutions created by 'rc-cli'.
      # TODO: Do it by specifying app_name
      if [[ $# -gt 1 ]]; then
        err "too many arguments"
        exit 1
      fi
      if [[ $# -gt 1 ]]; then
        err "too many arguments"
        exit 1
      fi
      # Prompt confirmation to delete user
      echo "WARNING! This will remove all logs, Docker images and solutions created by $0"
      read -r -p "Are you sure you want to continue? [y/N] " input
      case ${input} in
        [yY][eE][sS] | [yY])
          echo -n "Removing logs... "
          rm --recursive --force "logs/"
          echo "done"

          echo -n "Removing images... "
          rc_images=$(docker images --all --filter reference="*:rc-cli" --quiet)
          if [[ ${rc_images} ]]; then
            docker rmi --force ${rc_images} >& /dev/null >&2
          fi
          echo "done"

          echo -n "Removing solutions... "
          rm --force solutions/*.tar.gz
          echo "done"
          echo "Finished!"
          ;;
        [nN][oO] | [nN] | "")
          err "purge was canceled by the user"
          ;;
        *)
          err "invalid input: The purge was canceled"
          exit 1
          ;;
      esac
      ;;

    debug) # Enable an interactive shell at runtime to debug the app container.
      check_app "$@"
      echo "Debug mode:"
      echo "  - the default shell is /bin/sh"
      echo "  - find all valid login shells: cat /etc/shells"
      echo "  - switch to a preferred shell if available, e.g. /bin/bash"
      echo -e "  - \033[1mrun.sh has not been executed yet\033[0m"
      echo "  - use the 'exit' command to exit the current shell"
      echo
      echo "Enabling an interactive shell with the app container..."
      docker run --rm --entrypoint="" \
        --volume "$(pwd)"/data/inputs:/home/app/data/inputs:ro \
        --volume "$(pwd)"/data/outputs:/home/app/data/outputs \
        -it "${app_name}:rc-cli" sh
      ;;

    update) # Run maintenance commands after breaking changes on the framework.
      make_logs "$@"
      echo "Maintenance tasks will run now"
      build_image $1 ${DOCKER_BUILD_RC_TESTER}
      echo "Finished!"
      ;;

    *)
      err "$1: command not found"
      exit 1
      ;;
  esac
}

main "$@"
